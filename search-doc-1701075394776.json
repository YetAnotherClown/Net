[{"title":"Loop","type":0,"sectionRef":"#","url":"/Net/api/Loop","content":"On this page Loop A Matter Loop. For technical details, if you were to use a custom Loop object or try to integrate this Net Library in a ECS other than Matter, the Net:start() method is the equivalent of scheduling the Bridge:step() function to run first on the RunService.Heartbeat event. For more information on this, see the Bridge API","keywords":""},{"title":"Sending Data","type":0,"sectionRef":"#","url":"/Net/docs/handling-data/sending-data","content":"","keywords":""},{"title":"Identifiers & Data​","type":1,"pageTitle":"Sending Data","url":"/Net/docs/handling-data/sending-data#identifiers--data","content":"In the Net:send() method, the first Parameter will always be your Identifier. Identifiers are of type Net.Identifier or string. You must supply an Identifier when sending data and it should always come before you provide your data. It is recommended you use a Net.Identifier instead of a string, see Identifiers for more. Any other Parameters will be sent as data. "},{"title":"Specifying Recipients​","type":1,"pageTitle":"Sending Data","url":"/Net/docs/handling-data/sending-data#specifying-recipients","content":"In order to specify who to send the data to, you must use the [SendRequest:to] method. You can chain this onto Net:send() and pass in { Player }, Player, or Net.Server, local Players = game:GetService(&quot;Players&quot;) local MyIdentifier = identifiers.MyIdentifier Net:send(MyIdentifier, ...):to(Players:GetPlayers())  By default, when you do not specify any recipients, it will always send to all players. "},{"title":"Querying Data","type":0,"sectionRef":"#","url":"/Net/docs/handling-data/querying-data","content":"","keywords":""},{"title":"Filtering Identifiers​","type":1,"pageTitle":"Querying Data","url":"/Net/docs/handling-data/querying-data#filtering-identifiers","content":"The [Net:query] method allows you to filter Identifiers by passing a tuple as an argument. Supplying no Identifier will return all packets, otherwise only packets of the Identifier will be returned. local MyIdentifier = identifiers.MyIdentifier local MyOtherIdentifier = identifiers.MyOtherIdentifier for i, sender, identifier, args... in Net:query(MyIdentifier, MyOtherIdentifier) do -- Retrieves all packets with the specified identifiers end  "},{"title":"Filtering Senders​","type":1,"pageTitle":"Querying Data","url":"/Net/docs/handling-data/querying-data#filtering-senders","content":"Sometimes you may also want to filter by the sender. You can do this by chaining [QueryResult:from]onto the [Net:query] method and pass a tuple of Senders as the argument. Any of the following types are recognized as a sender: { Player } | Player | Net.Server  An example of this would be: local Players = game:GetService(&quot;Players&quot;) local MyIdentifier = identifiers.MyIdentifier for i, sender, identifier, args... in Net:query(MyIdentifier):from(Players) do -- Retrieves all packets with the specified identifier and from the table of players end  "},{"title":"Net","type":0,"sectionRef":"#","url":"/Net/api/Net","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Net","url":"/Net/api/Net#types","content":" "},{"title":"Configuration​","type":1,"pageTitle":"Net","url":"/Net/api/Net#Configuration","content":"Future Feature &lt;/&gt; interface Configuration { Channel: &quot;Reliable&quot; | &quot;Unreliable&quot;-- Default: Reliable DebugMode: boolean-- Enable Debug Features? DebugKey: KeyCode -- The key to open the Debug Panel Event: string-- The event to schedule Net on in your Matter Loop -- Default: &quot;default&quot; Middleware: ( sender, identifier, ... ) → any-- Ran before a packet is queried Ratelimit: number-- Amount of allowed invocations a frame } As of v0.2.0, the only configuration parameter that is implemented is Event. All other parameters will be implemented at a later date. With the exception of Middleware &amp; Ratelimiting, most of these parameters should not change and remain stable API. Channel Reliable: All packets will be sent and received per frame in order. Unreliable: Anticipated feature that Roblox may add, this is here for planning and is not yet available. "},{"title":"Functions​","type":1,"pageTitle":"Net","url":"/Net/api/Net#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Net","url":"/Net/api/Net#new","content":"&lt;/&gt; Net.new(configuration: Configuration?) → () Creates a new Net object with unique configuration. warning You should limit the amount of Net objects you create, each object runs on a separate RemoteEvent based on it's Channel and Event. Net Objects with the same Channel and Event will run on the same RemoteEvent. Net achieves it's performance gains by primarily reducing the overhead of RemoteEvent calls.  "},{"title":"query​","type":1,"pageTitle":"Net","url":"/Net/api/Net#query","content":"&lt;/&gt; Net:query() → QueryResult Allows for iteration of all packets of the previous frame. You can filter by Identifiers by adding them as function parameters. You can also filter by Senders by chaining the QueryResult:from() method onto the query method. See Querying Data for more information.  "},{"title":"send​","type":1,"pageTitle":"Net","url":"/Net/api/Net#send","content":"&lt;/&gt; Net:send() → () Sends data to all clients or to specific recipients under a given identifier. By default, Net:send will send the data to all Clients. You can specify which Clients to receive the data by chaining SendRequest:to and passing { Player }, Player, or Net.Server. See Sending Data for more information.  "},{"title":"start​","type":1,"pageTitle":"Net","url":"/Net/api/Net#start","content":"&lt;/&gt; Net:start( loop: Loop-- A Matter Loop ) → () Initializes your Net Server by adding middleware to your Matter Loop. This ensures that your netcode runs last every frame. note Please make sure that the event you set in the Configuration, or the default, is the same index you used for your RunService.Heartbeat event in your Loop:begin() method. Your netcode is meant to run on the heartbeat, like most systems. In some cases you may want to run your netcode on different events, in this case it is acceptable to change it to a different event. You should have different Net objects for each event in this case. "},{"title":"Compressing Data","type":0,"sectionRef":"#","url":"/Net/docs/handling-data/compressing-data","content":"","keywords":""},{"title":"Why it matters​","type":1,"pageTitle":"Compressing Data","url":"/Net/docs/handling-data/compressing-data#why-it-matters","content":"We live in a highly technologically advanced world today, despite this many households still have a subpar internet connection. Because of this, clients can only send and receive a limited amount of data in a given time frame. To ease this issue, we as programmers can optimize and reduce how much data we send over the internet, allowing for our players to spend more time playing and less time waiting for things to load. "},{"title":"Identifiers​","type":1,"pageTitle":"Compressing Data","url":"/Net/docs/handling-data/compressing-data#identifiers","content":"Simply put, Identifiers are strings. You could simply just use a string when sending or querying data as your Identifier. However, Net provides a function to compress strings into 2 bytes in order to optimize bandwidth. To create a Identifier, use Net.identifier(). For example, local MyIdentifier = Net.identifier(&quot;myIdentifier&quot;)  For more technical details on how Identifiers work, Identifiers are stored in a global table and are packed using string.pack()based on the position in which they are being packed. The global table looks something like: local IDENTIFIERS = { [Index] = PackedString }  Where Index is the string passed through the function and the PackedString is the return of running it throughstring.pack(&quot;B&quot;, pos). Because of the nature of this, and the design choice to promote strictly declared identifiers, creating identifiers dynamically after running any Net:start() may result in incorrect identifiers between the client and server. "},{"title":"QueryResult","type":0,"sectionRef":"#","url":"/Net/api/QueryResult","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"QueryResult","url":"/Net/api/QueryResult#functions","content":" "},{"title":"iterating over QueryResult​","type":1,"pageTitle":"QueryResult","url":"/Net/api/QueryResult#__iter","content":"&lt;/&gt; for number, Player | string, string, ...any in QueryResult do Iterating over a QueryResult will return the Packets in it's Snapshot that match the supplied Identifiers from Net:query and the supplied Senders from QueryResult:from. Usage: for pos, sender, identifier, ... in net:query(...identifiers):from(...senders) do -- Do something end   "},{"title":"from​","type":1,"pageTitle":"QueryResult","url":"/Net/api/QueryResult#from","content":"&lt;/&gt; QueryResult:from( senders: ...sender-- The Senders to filter ) → QueryResult Filters Packets from the QueryResult's Snapshot based on the provided Senders. "},{"title":"Net","type":0,"sectionRef":"#","url":"/Net/docs/intro","content":"","keywords":""},{"title":"Core Concepts​","type":1,"pageTitle":"Net","url":"/Net/docs/intro#core-concepts","content":""},{"title":"A brief introduction to Event-Driven Programming​","type":1,"pageTitle":"Net","url":"/Net/docs/intro#a-brief-introduction-to-event-driven-programming","content":"On Roblox, it is all too common. With the use of Signals, you can represent changes in state with and react to those changes with connections. A lot of how you interact with the DataModel and it's properties is through Events, this makes Roblox primarily Event-Driven. By making Roblox Event-Driven, this is where Roblox both succeeds and fails. They make things extremely simple for newcomers, but create issues for more experienced programmers. The biggest issue is that Event-Driven Programming fails when it comes to ordering. Failing to know when your code will run creates several issues later on. "},{"title":"A introduction to Data-Driven Programming​","type":1,"pageTitle":"Net","url":"/Net/docs/intro#a-introduction-to-data-driven-programming","content":"In a Data-Driven Architecture, Code runs in a fixed order, enabling developers to know exactly when something may change. This is something that Matter, a ECS System, strives to fix, and does a great job doing so. In Matter, it exists ways to incorporate a Data-Driven design to Event-Driven objects such as RemoteEvents on Roblox. It enables us to respond to Events and fire them in a fixed order. But we can do better. "},{"title":"An Introduction to Net​","type":1,"pageTitle":"Net","url":"/Net/docs/intro#an-introduction-to-net","content":""},{"title":"Why Net?​","type":1,"pageTitle":"Net","url":"/Net/docs/intro#why-net","content":"The Core issue of using RemoteEvents are the following: Event-Driven Code is sensitive to orderingDevelopers must create multiple RemoteEvents....Which is detrimental to organizationAnd, results in inefficient networking practices Matter alone fixes the first issue, but with Net you can fix them all. Net abstracts away the need to create multiple RemoteEvents and applies networking tricks to optimize bandwidth at the same time. Like BridgeNet2, Net utilizes a singular RemoteEvent and structures Data to send the least amount of bytes over networking calls. And with inspiration from the Bevy_Renet Crate and Matter itself, Net provides a effective API to use within an ECS. "},{"title":"Identifiers​","type":1,"pageTitle":"Net","url":"/Net/docs/intro#identifiers","content":"Simply put, Identifiers are strings. You could simply just use a string when sending or querying data as your Identifier. However, Net provides a function to compress strings into 2 bytes in order to optimize bandwidth. To create a Identifier, use Net.identifier(). For example, local MyIdentifier = Net.identifier(&quot;myIdentifier&quot;)  For more information on Identifiers and compressing data, see the Compressing Data page. "},{"title":"Sending Data​","type":1,"pageTitle":"Net","url":"/Net/docs/intro#sending-data","content":"To send data using Net, you can use the Net:send() method. For example, local MyIdentifier = Net.identifier(&quot;myIdentifier&quot;) Net:send(MyIdentifier, ...)  For more information on sending data, see the Sending Data page. "},{"title":"Querying Data​","type":1,"pageTitle":"Net","url":"/Net/docs/intro#querying-data","content":"To query data, you must iterate over it in a for loop. To do this, you can either iterate over the Net object itself or use the Net:query() method. By default, both of these options will return a tuple consisting ofposition, sender, identifier, args.... This may become a lot of values quickly, some of which you may not need. To solve this, you can pass in specific Types into the Net:query() method to filter them out. For example, local MyIdentifier = Net.identifier(&quot;myIdentifier&quot;) for i, sender, args... in Net:query(MyIdentifier) do -- Retrieves all packets with the specified identifier end  For more information on querying data, see the Querying Data page. "},{"title":"SendRequest","type":0,"sectionRef":"#","url":"/Net/api/SendRequest","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"SendRequest","url":"/Net/api/SendRequest#functions","content":" "},{"title":"to​","type":1,"pageTitle":"SendRequest","url":"/Net/api/SendRequest#to","content":"&lt;/&gt; SendRequest:to(recipient: {Player } | Player | &quot;NET_SERVER&quot;) → () Modifies the recipients of the packet to the one(s) provided in the parameter. "},{"title":"Bridge","type":0,"sectionRef":"#","url":"/Net/api/Bridge","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Bridge","url":"/Net/api/Bridge#types","content":" "},{"title":"orderedPayload​","type":1,"pageTitle":"Bridge","url":"/Net/api/Bridge#orderedPayload","content":"&lt;/&gt; interface orderedPayload { [Identifier]: {{ QueuePosition, any... }} } A Payload represents a singular table that will be sent over the RemoteEvent. It is structured in a way to minimize overhead when calling RemoteEvents. In order to guarantee the order of the queue, an additional value is packed into the packet data. In order to minimize overhead, the value is represented in a similar way as Identifiers.  "},{"title":"unorderedPayload​","type":1,"pageTitle":"Bridge","url":"/Net/api/Bridge#unorderedPayload","content":"Future Feature &lt;/&gt; interface unorderedPayload { [Identifier]: {{any...}} } A Payload represents a singular table that will be sent over the RemoteEvent. It is structured in a way to minimize overhead when calling RemoteEvents. By default, each queue will be ordered. This is a design choice in order to promote predictable and data-driven networking. "},{"title":"Functions​","type":1,"pageTitle":"Bridge","url":"/Net/api/Bridge#functions","content":" "},{"title":"_processOutgoingQueue​","type":1,"pageTitle":"Bridge","url":"/Net/api/Bridge#_processOutgoingQueue","content":"&lt;/&gt; Bridge:_processOutgoingQueue() → () Sends all queued outgoing packets over the Remote.  "},{"title":"_processIncoming​","type":1,"pageTitle":"Bridge","url":"/Net/api/Bridge#_processIncoming","content":"&lt;/&gt; Bridge:_processIncoming( sender: Player | &quot;NET_SERVER&quot;, payload: Payload ) → () Processes an incoming packet, adding it to the incoming queue.  "},{"title":"step​","type":1,"pageTitle":"Bridge","url":"/Net/api/Bridge#step","content":"&lt;/&gt; Bridge:step() → () Updates the incoming queue and snapshot and calls Bridge:_processOutgoingQueue().  "},{"title":"snapshot​","type":1,"pageTitle":"Bridge","url":"/Net/api/Bridge#snapshot","content":"&lt;/&gt; Bridge:snapshot() → () Returns a snapshot of the incoming queue. "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/Net/docs/getting-started","content":"","keywords":""},{"title":"Setting up with Matter​","type":1,"pageTitle":"Getting Started","url":"/Net/docs/getting-started#setting-up-with-matter","content":"Being made for the Matter ECS, Net provides a simple method for scheduling the Netcode to run on your Matter Loop. Firstly, similar to how you would setup your components with Matter, create a identifiers.luau ModuleScript to strictly declare your Net identifiers. Identifiers are global and should be the first thing you make when using the Net library. identifiers.luau local Net = require(Net) local IDENTIFIERS = { [&quot;ExampleOne&quot;] = Net.identifier(&quot;ExampleOne&quot;), [&quot;ExampleTwo&quot;] = Net.identifier(&quot;ExampleTwo&quot;) } -- Laid out for strict typing return IDENTIFIERS  And then in the same script you initialize your Matter Systems, you can create a new Net object with unique configuration by using the Net.new() function. For example, you can change the Event the Matter middleware for Net runs on in Configuration with the Event parameter. In order to use Net with Matter you must also use the Net:start() method and pass in your Matter loop. You should have only one Net object for every loop, though you shouldn't, in most cases, have more than one loop. This same setup should be ran on both the Client and the Server with the same configuration in order to work. init.server.luau / init.client.luau local Matter = require(Matter) local World = Matter.World local Loop = Matter.Loop local Net = require(Net) -- Create a new Net Server/Client local net = Net.new({ Channel: &quot;Reliable&quot; Event: &quot;default&quot;, }) -- Create your identifiers before initializing any netcode local identifiers = require(&quot;Identifiers.lua&quot;) local world = World.new() local loop = Loop.new(world, net) net:start(loop) -- Initializes the net, adding it to your loop. local systems = {} for _, child in script.systems:GetChildren() do if child:IsA(&quot;ModuleScript&quot;) then table.insert(systems, require(child)) end end loop:scheduleSystems(systems) -- Schedule systems after running Net:start() -- Begin the loop and make sure the eventName string you passed into Net:start() is in the event table loop:begin({ default = RunService.Heartbeat })  Finally, in a Matter System we can use our identifiers.luau ModuleScript to access our Identifiers and use them within our System. And, because we passed in our Net object into our Loop, we can use it in any of our Systems. We can send data using Net:send() and query it using Net:query(). systems/exampleSystem.luau local Identifiers = require(&quot;identifiers.luau&quot;) local ExampleIdentifier = Identifiers.ExampleOne local function exampleSystem(world, net) -- Query through every networking call that frame on the Server for i, player, identifier, args... in net:query(ExampleIdentifier) do -- Do something end -- Query through every networking call that frame on the Client for i, _, identifier, args... in net:query(ExampleIdentifier) do -- Do something end -- Send data from the Client to the Server net:send(ExampleIdentifier, ...) -- Send data to a Client from the Server net:send(ExampleIdentifier, ...):to(Player) end  "},{"title":"Other Setups​","type":1,"pageTitle":"Getting Started","url":"/Net/docs/getting-started#other-setups","content":"Is Matter not for you? It is possible to use Net outside of Matter by bypassing the Net:start() method and scheduling it with your own code using the internal mechanics of your Net object's Bridge. Please note that if you aren't using Net within an ECS it is strongly discouraged that you use it. You should consider using alternatives like BridgeNet2. Below is a simple example of creating custom scheduling behavior using Bridge:step(). local RunService = game:GetService(&quot;RunService&quot;) local Net = require(Net) -- Create a new Net Server/Client local net = NetLib.new() -- Create your identifiers before initializing any netcode local identifiers = require(&quot;Identifiers.lua&quot;) RunService.Heartbeat:Connect(function() net._bridge:step() -- The Bridge:step() method processes the incoming and outgoing queues end)  For more information on this, see the Bridge API. "}]