[{"title":"Loop","type":0,"sectionRef":"#","url":"/Net/api/Loop","content":"On this page Loop A Matter Loop. For technical details, if you were to use a custom Loop object or try to integrate this Net Library in a ECS other than Matter, the Net.start(loop, { Net }) function uses a similar implementation to Net.createHook({ Net }) internally. For more information on this, see Net.createHook.","keywords":""},{"title":"SendRequest","type":0,"sectionRef":"#","url":"/Net/api/SendRequest","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"SendRequest","url":"/Net/api/SendRequest#functions","content":" "},{"title":"to​","type":1,"pageTitle":"SendRequest","url":"/Net/api/SendRequest#to","content":"&lt;/&gt; SendRequest:to(recipient: {Player } | Player | &quot;NET_SERVER&quot;) → () Modifies the recipients of the packet to the one(s) provided in the parameter. "},{"title":"QueryResult","type":0,"sectionRef":"#","url":"/Net/api/QueryResult","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"QueryResult","url":"/Net/api/QueryResult#functions","content":" "},{"title":"iterating over QueryResult​","type":1,"pageTitle":"QueryResult","url":"/Net/api/QueryResult#__iter","content":"&lt;/&gt; for number, Player | string, ...any in QueryResult do Iterating over a QueryResult will return the Packets in the QueryResult's Snapshot that match the supplied Senders from QueryResult:from. Usage: for pos, sender, ... in net:query():from(...senders) do -- Do something end   "},{"title":"from​","type":1,"pageTitle":"QueryResult","url":"/Net/api/QueryResult#from","content":"&lt;/&gt; QueryResult:from( senders: ...sender-- The Senders to filter ) → QueryResult Filters Packets from the QueryResult's Snapshot based on the provided Senders. "},{"title":"Net","type":0,"sectionRef":"#","url":"/Net/docs/intro","content":"","keywords":""},{"title":"Core Concepts​","type":1,"pageTitle":"Net","url":"/Net/docs/intro#core-concepts","content":""},{"title":"A brief introduction to Event-Driven Programming​","type":1,"pageTitle":"Net","url":"/Net/docs/intro#a-brief-introduction-to-event-driven-programming","content":"On Roblox, it is all too common. With the use of Signals, you can represent changes in state with and react to those changes with connections. A lot of how you interact with the DataModel and it's properties is through Events, this makes Roblox primarily Event-Driven. By making Roblox Event-Driven, this is where Roblox both succeeds and fails. They make things extremely simple for newcomers, but create issues for more experienced programmers. The biggest issue is that Event-Driven Programming fails when it comes to ordering. Failing to know when your code will run creates several issues later on. "},{"title":"A introduction to Data-Driven Programming​","type":1,"pageTitle":"Net","url":"/Net/docs/intro#a-introduction-to-data-driven-programming","content":"In a Data-Driven Architecture, Code runs in a fixed order, enabling developers to know exactly when something may change. This is something that Matter, a ECS System, strives to fix, and does a great job doing so. In Matter, it exists ways to incorporate a Data-Driven design to Event-Driven objects such as RemoteEvents on Roblox. It enables us to respond to Events and fire them in a fixed order. But we can do better. "},{"title":"An Introduction to Net​","type":1,"pageTitle":"Net","url":"/Net/docs/intro#an-introduction-to-net","content":""},{"title":"Why Net?​","type":1,"pageTitle":"Net","url":"/Net/docs/intro#why-net","content":"The Core issue of using RemoteEvents are the following: Event-Driven Code is sensitive to orderingDevelopers must create multiple RemoteEvents....Which is detrimental to organizationAnd, results in inefficient networking practices Matter alone fixes the first issue, but with Net you can fix them all. Net abstracts away the need to create multiple RemoteEvents and applies networking tricks to optimize bandwidth at the same time. Like BridgeNet2, Net utilizes a singular RemoteEvent and structures Data to send the least amount of bytes over networking calls. And with inspiration from the Bevy_Renet Crate and Matter itself, Net provides a effective API to use within an ECS. "},{"title":"Creating Routes​","type":1,"pageTitle":"Net","url":"/Net/docs/intro#creating-routes","content":"Routes are the way you send and receive data through Net. They are uniquely identified so you're encouraged to create as many as you need as if you were creating individual RemoteEvents. Routes can be Reliable or Unreliable. Reliable events are never dropped and are always in order per frame. Unreliable events might be dropped on bad connections, but they are always received in order per frame. You can also strictly type Routes to get autocompletion and typechecking when Sending and Querying packets. To create a Route, you can use Net.new() local Net = require(&quot;Net.luau&quot;) type Net&lt;U...&gt; = Net.Net&lt;U...&gt; local PlayerLoaded: Net&lt;boolean&gt; = Net.new({ Channel = &quot;Reliable&quot; })  "},{"title":"Sending Data​","type":1,"pageTitle":"Net","url":"/Net/docs/intro#sending-data","content":"To send data using Net, you can use the Net:send() method. For example, local routes = require(&quot;routes.luau&quot;) local PlayerLoaded = routes.PlayerLoaded PlayerLoaded:send(true)  On the Server, you can also specify a player or players to send the packet to, local routes = require(&quot;routes.luau&quot;) local PlayerLoaded = routes.PlayerLoaded PlayerLoaded:send(true):to(Player)  "},{"title":"Querying Data​","type":1,"pageTitle":"Net","url":"/Net/docs/intro#querying-data","content":"To query data, you must iterate over it in a for loop. To do this, you can either iterate over the Route itself or use the Net:query() method. For example, local routes = require(&quot;routes.luau&quot;) local PlayerLoaded = routes.PlayerLoaded for i, sender, ...data in PlayerLoaded:query() do -- Retrieves all packets from the Route end  And you can query by sender, local routes = require(&quot;routes.luau&quot;) local PlayerLoaded = Routes.PlayerLoaded for i, _, ...data in PlayerLoaded:query():from(Player) do -- Retrieves all packets from the Route send by the Player end  "},{"title":"Net","type":0,"sectionRef":"#","url":"/Net/api/Net","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Net","url":"/Net/api/Net#types","content":" "},{"title":"Configuration​","type":1,"pageTitle":"Net","url":"/Net/api/Net#Configuration","content":"&lt;/&gt; interface Configuration { Channel: &quot;Reliable&quot; | &quot;Unreliable&quot;-- Default: Reliable Event: string-- The event to schedule the Route on in your Matter Loop -- Default: &quot;default&quot; Ratelimit: number-- Amount of allowed invocations a frame }  note As of v0.5.0, Ratelimiting is not implemented. This feature will come in future versions. Channel Reliable: All packets will be sent and received per frame in order. Unreliable: Packets may be dropped but will be received in order. "},{"title":"Functions​","type":1,"pageTitle":"Net","url":"/Net/api/Net#functions","content":" "},{"title":"start​","type":1,"pageTitle":"Net","url":"/Net/api/Net#start","content":"&lt;/&gt; Net.start( loop: Loop,-- A Matter Loop routes: {Net}-- A table of your Routes ) → () Initializes your Routes by adding middleware to your Matter Loop. This ensures that your Routes run between each frame. note Please make sure that the event you set in the Configuration, or the default, is the same index you used for yourRunService.Heartbeat event in your Loop:begin() method. Your Routes are meant to run on the heartbeat, like most systems. In some cases you may want to run your Routes on different events, in this case it is acceptable to change it to a different event.  "},{"title":"createHook​","type":1,"pageTitle":"Net","url":"/Net/api/Net#createHook","content":"&lt;/&gt; Net.createHook( routes: {Net}-- A table of your Routes ) → () → () This function allows you to run Net scheduling code on your own events. When you provide a table of Routes, this function will return another function you can call which will step each Route and process it's Packet Queue. For example, to run scheduling on the Heartbeat: local hook = Net.createHook({ Net }) RunService.Heartbeat:Connect(hook)   "},{"title":"new​","type":1,"pageTitle":"Net","url":"/Net/api/Net#new","content":"&lt;/&gt; Net.new(configuration: Configuration?) → () Creates a new Route with a unique identifier, channel, and event. note All Routes with the same Channel will share a single Remote. It's recommended that you run all your Net scheduling code on a single event.  "},{"title":"query​","type":1,"pageTitle":"Net","url":"/Net/api/Net#query","content":"&lt;/&gt; Net:query() → QueryResult Allows for iteration of all packets of the previous frame. You can filter by Senders by chaining the QueryResult:from() method onto the query method. note Due to certain limitations with the Luau Type System, iterating over the QueryResult Object will not return typed values. In order to fix this, call :__iter() on the QueryResult Object. For example: for i, sender, ... in net:query():__iter() do -- Do something end See Querying Data for more information.  "},{"title":"send​","type":1,"pageTitle":"Net","url":"/Net/api/Net#send","content":"&lt;/&gt; Net:send() → () Sends data to all clients or to specific recipients from the Route's identifier. By default, Net:send will send the data to all Clients. You can specify which Clients to receive the data by chaining SendRequest:to and passing { Player }, Player, or Net.Server. See Sending Data for more information. "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/Net/docs/getting-started","content":"","keywords":""},{"title":"Setting up with Matter​","type":1,"pageTitle":"Getting Started","url":"/Net/docs/getting-started#setting-up-with-matter","content":"Being made for the Matter ECS, Net provides a simple method for scheduling your Routes to run on your Matter Loop. Firstly, create a routes.luau ModuleScript in ReplicatedStorage to strictly declare your Routes. routes.luau local Net = require(&quot;Net.luau&quot;) type Net&lt;U...&gt; = Net.Net&lt;U...&gt; local defaultConfiguration = { Channel = &quot;Reliable&quot;, Event = &quot;default&quot;, } -- Payload for replicating Entities type EntityPayload = { [string]: { -- EntityId [string]: { -- Component name data: ComponentInstance&lt;T&gt; } } } -- Replicate Matter Components local MatterReplication: Net&lt;EntityPayload&gt; = Net.new(defaultConfiguration) -- Signal that the Player has loaded local PlayerLoaded: Net&lt;boolean&gt; = Net.new(defaultConfiguration) return { MatterReplication = MatterReplication, PlayerLoaded = PlayerLoaded, }  And now in the same script where you create your Matter Loop, you can run the Net.start({ Net })function to schedule your Routes to run on Matter's Middleware. init.server.luau / init.client.luau local Matter = require(&quot;Matter.luau&quot;) local World = Matter.World local Loop = Matter.Loop local Net = require(&quot;Net.luau&quot;) local routes = require(&quot;routes.luau&quot;) local world = World.new() local loop = Loop.new(world) -- Schedules your Routes Net.start(loop, routes) local systems = {} for _, child in script.systems:GetChildren() do if child:IsA(&quot;ModuleScript&quot;) then table.insert(systems, require(child)) end end loop:scheduleSystems(systems) -- Schedule systems after running ``Net.start()`` -- Begin the loop and make sure the ``Event`` key in your Routes configuration are added here loop:begin({ default = RunService.Heartbeat })  Finally, in a Matter System we can use our routes.luau ModuleScript to access our Routes and use them within our Systems. systems/exampleSystem.luau local routes = require(&quot;routes.luau&quot;) local PlayerLoaded = routes.PlayerLoaded local function exampleSystem(world) -- Query through every networking call that frame on the Server for i, player, ...data in PlayerLoaded:query() do -- Do something end -- Query through every networking call that frame on the Client for i, _, ...data in PlayerLoaded:query() do -- Do something end -- Send data from the Client to the Server PlayerLoaded:send(...) -- Send data to a Client from the Server PlayerLoaded:send(...):to(Player) end  "},{"title":"Other Setups​","type":1,"pageTitle":"Getting Started","url":"/Net/docs/getting-started#other-setups","content":"Is Matter not for you? It is possible to use Net outside of Matter by creating a Hook using Net.createHook({ Net })which is identical to the Net.start(loop, { Net }) function. This function will return another function which you can call whenever you want to process your Routes' queues and send/receive your Packets on the Server or Client. Below is a simple example of creating custom scheduling behavior using Net.createHook({ Net }), local RunService = game:GetService(&quot;RunService&quot;) local Net = require(&quot;Net.luau&quot;) local routes = require(&quot;routes.luau&quot;) local hook = Net.createHook(routes) RunService.Heartbeat:Connect(hook)  "}]