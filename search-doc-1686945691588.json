[{"title":"Compressing Data","type":0,"sectionRef":"#","url":"/Net/docs/handling-data/compressing-data","content":"","keywords":""},{"title":"Why it matters​","type":1,"pageTitle":"Compressing Data","url":"/Net/docs/handling-data/compressing-data#why-it-matters","content":"We live in a highly technologically advanced world today, despite this many households still have a subpar internet connection. Because of this, clients can only send and receive a limited amount of data in a given time frame. To ease this issue, we as programmers can optimize and reduce how much data we send over the internet, allowing for our players to spend more time playing and less time waiting for things to load. "},{"title":"Identifiers​","type":1,"pageTitle":"Compressing Data","url":"/Net/docs/handling-data/compressing-data#identifiers","content":"Simply put, Identifiers are strings. You could simply just use a string when sending or querying data as your Identifier. However, Net provides a function to compress strings into 2 bytes in order to optimize bandwidth. To create a Identifier, use Net.identifier(). For example, local MyIdentifier = Net.identifier(&quot;myIdentifier&quot;)  For more technical details on how Identifiers work, Identifiers are stored in a global table and are packed using string.pack()based on the position in which they are being packed. The global table looks something like: local identifiers = { [Index] = PackedString }  Where Index is the string passed through the function and the PackedString is the return of running it throughstring.pack(&quot;B&quot;, pos). Because of the nature of this, and the design choice to promote strictly declared identifiers, creating identifiers dynamically after running any Net:start() may result in incorrect identifiers between the client and server. "},{"title":"Loop","type":0,"sectionRef":"#","url":"/Net/api/Loop","content":"On this page Loop A Matter Loop. For technical details, if you were to use a custom Loop object or try to integrate this Net Library in a ECS other than Matter, the Net:start() method is the equivalent of scheduling the Bridge:step() function to run first on the RunService.Heartbeat event. To use it outside of any ECS, you could use the following code: RunService.Heartbeat:Connect(function() Net._bridge:step() end) Otherwise, you can use the Bridge:step() method to integrate it into other ECS libraries.","keywords":""},{"title":"Querying Data","type":0,"sectionRef":"#","url":"/Net/docs/handling-data/querying-data","content":"Querying Data To query data, you must iterate over it in a for loop. To do this, you can either iterate over the Net object itself or use the Net:query() method. By default, both of these options will return a tuple consisting ofposition, sender, identifier, args.... This may become a lot of values quickly, some of which you may not need. To solve this, you can pass in specific Types into the Net:query() method to filter them out. For example, local MyIdentifier = Net.identifier(&quot;myIdentifier&quot;) for i, sender, args... in Net:query(MyIdentifier) do -- Retrieves all packets with the specified identifier end This example only filters out the Identifier. We can also filter out by the Sender by adding{ Players }, Player, or Net.Server. for i, args... in Net:query(YetAnotherClown, MyIdentifier) do -- Retrieves all packets from YetAnotherClown with the specified Identifier end Great, so we managed to filter out both our Sender and Identifier arguments. But what if we provide multiple Identifiers or Players? When a table or tuple of Players, or a tuple of Identifiers is provided, the iterator will return the sender and identifier respectfully as neither is known beforehand. local MyIdentifier = Net.identifier(&quot;myIdentifier&quot;) local MyOtherIdentifier = Net.identifier(&quot;myIdentifier&quot;) for i, identifier, args... in Net:query(MyIdentifier, MyOtherIdentifier) do -- Retrieves all packets of the specified identifiers end ","keywords":""},{"title":"Sending Data","type":0,"sectionRef":"#","url":"/Net/docs/handling-data/sending-data","content":"Sending Data Data is sent through a queue each frame. The library will queue up all data sent through the Net:send() method and send it through a RemoteEvent at the start of a new frame. To send data using Net, you can use the Net:send() method. For example, local MyIdentifier = Net.identifier(&quot;myIdentifier&quot;) Net:send(MyIdentifier, ...) In the Net:send() method, the first Parameters you provide should be the Recipients of your packet. These can be of types { Players } or Player if called from the Server, or Net.Server if called from the client. If you call from the client, you do not have to provide a Recipient Parameter. The next Parameter after your Recipients should be an Identifier. Identifiers are of type Net.Identifier or string. You must supply an Identifier when sending data and it should always come before you provide your data. It is recommended you use a Net.Identifier instead of a string, see Identifiers for more. Any other Parameters will be sent as data.","keywords":""},{"title":"Net","type":0,"sectionRef":"#","url":"/Net/docs/intro","content":"","keywords":""},{"title":"Core Concepts​","type":1,"pageTitle":"Net","url":"/Net/docs/intro#core-concepts","content":""},{"title":"A brief introduction to Event-Driven Programming​","type":1,"pageTitle":"Net","url":"/Net/docs/intro#a-brief-introduction-to-event-driven-programming","content":"On Roblox, it is all too common. With the use of Signals, you can represent changes in state with and react to those changes with connections. A lot of how you interact with the DataModel and it's properties is through Events, this makes Roblox primarily Event-Driven. By making Roblox Event-Driven, this is where Roblox both succeeds and fails. They make things extremely simple for newcomers, but create issues for more experienced programmers. The biggest issue is that Event-Driven Programming fails when it comes to ordering. Failing to know when your code will run creates several issues later on. "},{"title":"A introduction to Data-Driven Programming​","type":1,"pageTitle":"Net","url":"/Net/docs/intro#a-introduction-to-data-driven-programming","content":"In a Data-Driven Architecture, Code runs in a fixed order, enabling developers to know exactly when something may change. This is something that Matter, a ECS System, strives to fix, and does a great job doing so. In Matter, it exists ways to incorporate a Data-Driven design to Event-Driven objects such as RemoteEvents on Roblox. It enables us to respond to Events and fire them in a fixed order. But we can do better. "},{"title":"An Introduction to Net​","type":1,"pageTitle":"Net","url":"/Net/docs/intro#an-introduction-to-net","content":""},{"title":"Why Net?​","type":1,"pageTitle":"Net","url":"/Net/docs/intro#why-net","content":"The Core issue of using RemoteEvents are the following: Event-Driven Code is sensitive to orderingDevelopers must create multiple RemoteEvents....Which is detrimental to organizationAnd, results in inefficient networking practices Matter alone fixes the first issue, but with Net you can fix them all. Net abstracts away the need to create multiple RemoteEvents and applies networking tricks to optimize bandwidth at the same time. Like BridgeNet2, Net utilizes a singular RemoteEvent and structures Data to send the least amount of bytes over networking calls. And with inspiration from the Bevy_Renet Crate and Matter itself, Net provides a effective API to use within an ECS. "},{"title":"Identifiers​","type":1,"pageTitle":"Net","url":"/Net/docs/intro#identifiers","content":"Simply put, Identifiers are strings. You could simply just use a string when sending or querying data as your Identifier. However, Net provides a function to compress strings into 2 bytes in order to optimize bandwidth. To create a Identifier, use Net.identifier(). For example, local MyIdentifier = Net.identifier(&quot;myIdentifier&quot;)  For more information on Identifiers and compressing data, see the Compressing Data page. "},{"title":"Sending Data​","type":1,"pageTitle":"Net","url":"/Net/docs/intro#sending-data","content":"To send data using Net, you can use the Net:send() method. For example, local MyIdentifier = Net.identifier(&quot;myIdentifier&quot;) Net:send(MyIdentifier, ...)  For more information on sending data, see the Sending Data page. "},{"title":"Querying Data​","type":1,"pageTitle":"Net","url":"/Net/docs/intro#querying-data","content":"To query data, you must iterate over it in a for loop. To do this, you can either iterate over the Net object itself or use the Net:query() method. By default, both of these options will return a tuple consisting ofposition, sender, identifier, args.... This may become a lot of values quickly, some of which you may not need. To solve this, you can pass in specific Types into the Net:query() method to filter them out. For example, local MyIdentifier = Net.identifier(&quot;myIdentifier&quot;) for i, sender, args... in Net:query(MyIdentifier) do -- Retrieves all packets with the specified identifier end  For more information on querying data, see the Querying Data page. "},{"title":"Bridge","type":0,"sectionRef":"#","url":"/Net/api/Bridge","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Bridge","url":"/Net/api/Bridge#types","content":" "},{"title":"orderedPayload​","type":1,"pageTitle":"Bridge","url":"/Net/api/Bridge#orderedPayload","content":"&lt;/&gt; interface orderedPayload { [Identifier]: {{ QueuePosition, any... }} } A Payload represents a singular table that will be sent over the RemoteEvent. It is structured in a way to minimize overhead when calling RemoteEvents. In order to guarantee the order of the queue, an additional value is packed into the packet data. In order to minimize overhead, the value is represented in a similar way as Identifiers.  "},{"title":"unorderedPayload​","type":1,"pageTitle":"Bridge","url":"/Net/api/Bridge#unorderedPayload","content":"Future Feature &lt;/&gt; interface unorderedPayload { [Identifier]: {{any...}} } A Payload represents a singular table that will be sent over the RemoteEvent. It is structured in a way to minimize overhead when calling RemoteEvents. By default, each queue will be ordered. This is a design choice in order to promote predictable and data-driven networking. To make the queue unordered, set the Channel to ReliableUnordered in the Configuration. As of v0.1.0, the ReliableUnordered Channel is not implemented. "},{"title":"Functions​","type":1,"pageTitle":"Bridge","url":"/Net/api/Bridge#functions","content":" "},{"title":"_processOutgoingQueue​","type":1,"pageTitle":"Bridge","url":"/Net/api/Bridge#_processOutgoingQueue","content":"&lt;/&gt; Bridge:_processOutgoingQueue() → () Sends all queued outgoing packets over the Remote.  "},{"title":"_processIncoming​","type":1,"pageTitle":"Bridge","url":"/Net/api/Bridge#_processIncoming","content":"&lt;/&gt; Bridge:_processIncoming( sender: Player | &quot;NET_SERVER&quot;, payload: Payload ) → () Processes an incoming packet, adding it to the incoming queue.  "},{"title":"step​","type":1,"pageTitle":"Bridge","url":"/Net/api/Bridge#step","content":"&lt;/&gt; Bridge:step() → () Updates the incoming queue and snapshot and calls Bridge:_processOutgoingQueue().  "},{"title":"snapshot​","type":1,"pageTitle":"Bridge","url":"/Net/api/Bridge#snapshot","content":"&lt;/&gt; Bridge:snapshot() → () Returns a snapshot of the incoming queue.  "},{"title":"send​","type":1,"pageTitle":"Bridge","url":"/Net/api/Bridge#send","content":"&lt;/&gt; Bridge:send() → () Queue a packet to be sent in the outgoing queue "},{"title":"Net","type":0,"sectionRef":"#","url":"/Net/api/Net","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Net","url":"/Net/api/Net#types","content":" "},{"title":"Configuration​","type":1,"pageTitle":"Net","url":"/Net/api/Net#Configuration","content":"Future Feature &lt;/&gt; interface Configuration { Channel: &quot;Reliable&quot; | &quot;Unreliable&quot;-- Default: Reliable DebugMode: boolean-- Enable Debug Features? DebugKey: KeyCode -- The key to open the Debug Panel Middleware: ( sender, identifier, ... ) → any-- Ran before a packet is queried Ratelimit: number-- Amount of allowed invocations a frame } As of v0.1.0, none of these are implemented. All are planned and will be implemented in later versions. "},{"title":"Functions​","type":1,"pageTitle":"Net","url":"/Net/api/Net#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Net","url":"/Net/api/Net#new","content":"&lt;/&gt; Net.new(configuration: Configuration?) → () Creates a new Net object with unique configuration. warning You should limit the amount of Net objects you create, each object runs on a separate RemoteEvent. Net achieves it's performance gains by primarily reducing the overhead of RemoteEvent calls.  "},{"title":"query​","type":1,"pageTitle":"Net","url":"/Net/api/Net#query","content":"&lt;/&gt; Net:query() → () → ( pos: number, sender: (Player | string)?, identifier: (string)?, packetData: any... ) Allows for iteration of all packets of the previous frame with support for QueryParameters. QueryParameters can be Player, {Players}, or Identifier. When provided, related return values will not be returned. See Querying Data for more information.  "},{"title":"send​","type":1,"pageTitle":"Net","url":"/Net/api/Net#send","content":"&lt;/&gt; Net:send() → () Sends data to a recipient or the server if not specified under a unique identifier. See Sending Data for more information.  "},{"title":"start​","type":1,"pageTitle":"Net","url":"/Net/api/Net#start","content":"&lt;/&gt; Net:start( loop: Loop,-- An optional First Parameter that specifies a recipient of Player, { Player }, or Net.Server. If not specified, the packet will be sent to the server. event: string,-- The Index of the Event you want Net to use in your Loop:begin() method. priorityOverride: number-- A optional override for the priority of the Net System/ ) → () Initializes your Net Server by scheduling it on your Matter Loop. This ensures that your netcode runs first every frame. note Please make sure that the event you provided is the same index you used for your RunService.Heartbeat event in your Loop:begin() method. Your netcode is meant to run on the heartbeat, like most systems. In some cases you may want to run your netcode on different events, in this case it is acceptable to change it to a different event. You should have different netcodes for each event in this case. warning The start method assumes your systems are ordered from 0 to inf. If you have any systems that run on a priority below zero, you should either change your system's priority or manually set the priority in the start method. If your netcode runs after any system, it may cause undesired behavior. "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/Net/docs/getting-started","content":"","keywords":""},{"title":"Setting up with Matter​","type":1,"pageTitle":"Getting Started","url":"/Net/docs/getting-started#setting-up-with-matter","content":"Being made for the Matter ECS, Net provides a simple method for scheduling the Netcode to run on your Matter Loop. Firstly, similar to how you would setup your components with Matter, create a identifiers.luau ModuleScript to strictly declare your Net identifiers. Identifiers are global and should be the first thing you make when using the Net library. identifiers.luau local Net = require(Net) local identifiers = { [&quot;ExampleOne&quot;] = Net.identifier(&quot;ExampleOne&quot;), [&quot;ExampleTwo&quot;] = Net.identifier(&quot;ExampleTwo&quot;) } -- Laid out for strict typing return identifiers  And then in the same script you initialize your Matter Systems, you can create a new Net object with unique configuration by using the Net.new() function. In order to use Net with Matter you must also use the Net:start() method and pass in your Matter loop and the name of the event to run on. The event should be Heartbeat. You should have only one Net object for every loop, though you shouldn't, in most cases, have more than one loop. init.server.luau / init.client.luau local Matter = require(Matter) local World = Matter.World local Loop = Matter.Loop local NetLib = require(Net) -- Create a new Net Server/Client local Net = NetLib.new({ Channel: ReliableOrdered | ReliableUnordered | Unreliable, -- Future proofing DebugMode: boolean -- Tools for debugging DebugKey: KeyCode -- Future addition for a Debug Panel Middleware: (sender, identifier, ...) -&gt; any -- Ran before a packet is queried RateLimit: number -- Amount of invocations a second }) -- Create your identifiers before initializing any netcode local identifiers = require(&quot;Identifiers.lua&quot;) local world = World.new() local loop = Loop.new(world, Net) Net:start(loop, &quot;default&quot;) -- Initializes the net, adding it to your loop. local systems = {} for _, child in script.systems:GetChildren() do if child:IsA(&quot;ModuleScript&quot;) then table.insert(systems, require(child)) end end loop:scheduleSystems(systems) -- Schedule systems after running Net:start() -- Begin the loop and make sure the eventName string you passed into Net:start() is in the event table loop:begin({ default = RunService.Heartbeat })  Finally, in a Matter System we can use our identifiers.luau ModuleScript to access our Identifiers and use them within our System. And, because we passed in our Net object into our Loop, we can use it in any of our Systems. We can send data using Net:send() and query it using Net:query(). systems/exampleSystem.luau local identifiers = require(&quot;identifier.luau&quot;) local ExampleIdentifier = identifiers.ExampleOne local function exampleSystem(world, net) -- Query through every networking call that frame from Clients for i, player, args... in net:query(ExampleIdentifier) do -- Do something end -- Query through every networking call that frame from the Server for i, args... in net:query(ExampleIdentifier) do -- Do something end -- Send data from the Client to the Server net:send(ExampleIdentifier, ...) -- Send data to a Client from the Server net:send(Player, ExampleIdentifier, ...) end  "},{"title":"Other Setups​","type":1,"pageTitle":"Getting Started","url":"/Net/docs/getting-started#other-setups","content":"Is Matter not for you? It is possible to use Net outside of Matter by bypassing the Net:start() method and scheduling it with your own code using the internal mechanics of your Net object's Bridge. Please note that if you aren't using Net within an ECS it is strongly discouraged that you use it. You should consider using alternatives like BridgeNet2. Below is a simple example of creating custom scheduling behavior using Bridge:step(). local RunService = game:GetService(&quot;RunService&quot;) local NetLib = require(Net) -- Create a new Net Server/Client local Net = NetLib.new({ Channel: ReliableOrdered | ReliableUnordered | Unreliable, -- Future proofing DebugMode: boolean -- Tools for debugging DebugKey: KeyCode -- Future addition for a Debug Panel Middleware: (sender, identifier, ...) -&gt; any -- Ran before a packet is queried RateLimit: number -- Amount of invocations a second }) -- Create your identifiers before initializing any netcode local identifiers = require(&quot;Identifiers.lua&quot;) RunService.Heartbeat:Connect(function() Net._bridge:step() -- The Bridge:step() method processes the incoming and outgoing queues end)  For more information on this, see the Bridge API. "}]